# Determination of a finite automaton with multiple initial states

The finite automaton determinism algorithm is a key tool in the theory of formal languages. It finds extensive practical use in word processing, data analysis and in various areas of Computer Science. By converting non-deterministic Automata to deterministic, it enables efficient language analysis, which is key in compilers, text analysis, regular expression search, network management, database systems, and many other applications.
The task is to find a deterministic finite automaton without unnecessary and unattainable states such that the language it receives is equivalent to the language of a given non-deterministic finite automaton with multiple initial states.
Implement the determinization in the form of a program function in C++, whose signature is: DFA determine ( const MISNFA & nfa);. The input or output of the algorithm are Automata in the form of MISNFA or DFA structures representing a nondeterministic finite automaton with multiple numbers. States or deterministic finite automata. These structures are defined in the test environment, see sample below. For simplicity, states are defined as values of type int, and alphabetic symbols as values of type char.
Comparison of Automata with the reference result is carried out through conversion to a minimum deterministic finite automaton. Your outputs may vary (e.g. in state naming). However, after converting to a minimum automaton, which the test environment will perform (i.e. minimization is not your concern), it must give an equivalent automaton (naming States does not play a role).
It is guaranteed that a valid nondeterministic finite automaton with multiple initial States arrives at the input, i.e.:
sets of states (MISNFA:: mStates), initial states (MISNFA::mInitialStates) and Alphabet symbols (MISNFA::m_Alphabet) will be non-empty,
the start and end States from the MISNFA::mInitialStates and MISNFA::mFinalStates sets will also be elements of the MISNFA::m_States state set,
if for some state there is no q and an alphabet symbol and a defined transition in the automaton, then in the MISNFA::m_transions map the value assigned to the key (q, a) will not be an empty set, but this key will not exist at all,
in the MISNFA::m_transions transition map, there are also only elements that are specified in the set of Alphabet symbols and statuses.
The resulting DFA must also meet the conditions of the automaton definition, that is, it must apply the same as above for MISNFA (except for obvious changes due to different definitions of the initial state and the transition function).
If the language of the slot machine is empty, cast the single-state slot machine over the same alphabet as the original slot machine.
